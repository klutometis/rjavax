# -*- org -*-
* TODO we appear to be doing something fundamentally wrong with refClasses
  in ~setJavaInterfaceImplementation~: 'jobjInterfaceRef' becomes part
  of the package/global namespace, doesn't it? Shouldn't we therefore
  name it after the implementation/interface?

  Take care, then, because we're polluting the namespace with
  dynamically generated refClass-names.

  Should we add a ~where~ to ~setJavaInterfaceImplementation~ that
  defaults to something suitable?
* TODO use proper namespacing
  =com/gene/rJavax=, etc.
* TODO switch to ant instead of Makefiles
  can even use [[http://cran.r-project.org/web/packages/ant/index.html][ant]] (but it's really just a wrapper around =system=).
* DONE integration of proxy-object with package
  CLOSED: [2011-05-11 Wed 14:04]
  Of course: we can't integrate it statically, because we have to
  instantiate a reference object! Damn.

  #+BEGIN_SRC R :tangle integrate-proxy-object.R :noweb yes :shebang #!/usr/local/bin/R --vanilla --slave -f
    <<preamble>>
    
    proxyMethods <- function(class) {
      method.names <- unique(Map(function(method) method$getName(),
                                 as.list(J('java.lang.Class')
                                         $forName(class)
                                         $getMethods())))
    
      proxyObject <- new(J(class)) 
    
      structure(Map(function(method.name)
                    ## Have to force evaluation because `method.name'
                    ## and `proxyObject' aren't defined from the
                    ## refClass.
                    eval(substitute(function(...) {
                      .jrcall(proxyObject, method.name, ...)
                    },
                                    list(method.name=method.name,
                                         proxyObject=proxyObject))),
                    method.names),
                names=method.names)
    }
    
    ##' Implement the Java-\code{interface} with a \code{refClass}-based
    ##' \code{implementation}.
    ##' @param interface the name of the to-be-implemented Java interface
    ##' @param implementation an instance of the implementing \code{refClass}
    ##' @return a \code{refClass} implementing the Java \code{interface}
    ##' @note \code{implementation} takes an instance of the
    ##' \code{refClass}, not the \code{refClass} itself; allowing one to
    ##' make use of peculiar initializers.
    ##' @export
    setJavaInterfaceImplementation <- function(interface,
                                               implementation,
                                               base='java.lang.Object') {
      ## Should we use a class-name based on the implementation/interface?
      setRefClass('jobjInterfaceRef',
                  contains=c(implementation@.xData$.refClassDef@className),
                  fields='proxy',
                  methods=c(eval(substitute(proxyMethods(base),
                    list(base=base))),
                    initialize=eval(substitute(function() {
                      proxy <<-
                        interfaceProxy(interface, implementation)
                      .self
                    }),
                      list(interface=interface,
                           implementation=implementation))),
                  ## Running into "cannot add bindings to a locked
                  ## environment" without this; is something fundamentally
                  ## wrong with our approach?
                  ##
                  ## See TODO: we'll pollute the namespace with
                  ## dynamically generated names based on e.g.
                  where=topenv(parent.frame()))
    }
    
    testInterfaceImplementation <-
      setRefClass('testInterfaceImplementation',
                  methods=list(salute=function(salutandum)
                    sprintf('Salve, %s!', salutandum)))
    
    testInterface <-
      setJavaInterfaceImplementation('TestInterfaceProxyInterface',
                                     testInterfaceImplementation$new())
    
    stopifnot(typeof(testInterface$new()$hashCode()) == 'integer')
    
  #+END_SRC
* DONE abstract proxy-object into a constructor
  CLOSED: [2011-05-11 Wed 13:16]
  - CLOSING NOTE [2011-05-11 Wed 13:16] \\
    Between magically bound identifiers and ~substitute~, this is weird
    shit.
  #+BEGIN_SRC R :tangle proxy-object.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit()
    
    proxyObject <- function(class) {
      method.names <- unique(Map(function(method) method$getName(),
                                 as.list(J('java.lang.Class')
                                         $forName(class)
                                         $getMethods())))
    
    
      methods <-
        structure(Map(function(method.name)
                      ## Have to force evaluation because `method.name'
                      ## isn't defined from the refClass.
                      eval(substitute(function(...) {
                        ## `deferendum' is magically bound within the
                        ## refClass environment.
                        .jrcall(deferendum, method.name, ...)
                      },
                                      list(method.name=method.name))),
                      method.names),
                  names=method.names)
    
      setRefClass('objectDeference',
                  fields='deferendum',
                  methods=c(methods,
                    initialize=eval(substitute(function() {
                      deferendum <<- eval(substitute(new(J(class)), list(class=class)))
                      .self
                    }),
                      list(class=class))))
    }
    
    stopifnot(typeof(proxyObject('java.lang.Object')$new()$hashCode()) ==
              'integer')
    
  #+END_SRC
* DONE get methods for a java class
  CLOSED: [2011-05-11 Wed 13:16]
  [[http://tutorials.jenkov.com/java-reflection/private-fields-and-methods.html][The difference]] between ~getMethods()~ and ~getDeclaredMethods()~:

  #+BEGIN_QUOTE
  To access a private field you will need to call the
  ~Class.getDeclaredField(String name)~ or ~Class.getDeclaredFields()~
  method. The methods ~Class.getField(String name)~ and
  ~Class.getFields()~ methods only return public fields, so they won't
  work.
  #+END_QUOTE

  Can apparently not access ~methods~ from within ~methods~:

  #+BEGIN_SRC R :tangle methods-from-methods.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    setRefClass('methodsFromMethods',
                methods=list(a=function() {},
                  initialize=function() {
                    str(methods)
                    cat(ls(.self@.xData))
                    .self
                  }))$new()    
  #+END_SRC

  That's ok, though: we have an implementing refClass that we're
  passing in. Should we create a proxy refClass from Object that we
  also inherit from, allowing its methods to be over-shadowed by the
  implementing refClass?

  First contained class takes precedence w.r.t. method-shadowing:

  #+BEGIN_SRC R :tangle refclass-shadow.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    setRefClass('a',
                methods=list(a=function() 1))
    
    setRefClass('b',
                methods=list(a=function() 2))
    
    stopifnot(setRefClass('c',
                          contains=c('a', 'b'))$new()$a() == 1)
    
    stopifnot(setRefClass('d',
                          contains=c('b', 'a'))$new()$a() == 2)
  #+END_SRC

  This, for instance, does not work:

  #+BEGIN_SRC R :tangle add-dynamic-methods.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    setRefClass('a',
                methods=list(initialize=function() {
                  unlockBinding('methods', parent.frame())
                  methods <<- list(a=function() 1)
                  .self
                }))$new()$a()
    
  #+END_SRC

  We need another mechanism: ~substitute~ to the rescue?

  #+BEGIN_SRC R :tangle substitute-dynamic-methods.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    stopifnot(eval(substitute(setRefClass('a', methods=methodList),
                              list(methodList=list(a=function() 2))))$new()$a()
              == 2)
    
    stopifnot((function(methodList)
               setRefClass('b', methods=methodList))(list(a=function()
                                  2))$new()$a()
              == 2)    
  #+END_SRC

  #+BEGIN_SRC R :tangle defer-to-proxy-object.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit()
    
    method.names <- unique(Map(function(method) method$getName(),
                               as.list(J('java.lang.Class')
                                       $forName('java.lang.Object')
                                       $getMethods())))
    
    proxyObject = new(J('java.lang.Object'))
    
    methods <-
      structure(Map(function(method.name)
                    ## Have to force evaluation because `method.name'
                    ## isn't defined from the refClass.
                    eval(substitute(function(...) {
                      .jrcall(proxyObject, method.name, ...)
                    },
                                    list(method.name=method.name))),
                    method.names),
                names=method.names)
    
    stopifnot(methods$hashCode() ==
              setRefClass('objectDeference',
                          fields='deferendum',
                          methods=methods)$new()$hashCode())
  #+END_SRC
* DONE introspect Object
  CLOSED: [2011-05-11 Wed 10:22]
  #+BEGIN_SRC R :tangle introspect-object.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit()
    
    stopifnot(unique(Map(function(method) method$getName(),
                         as.list(J('java.lang.Class')
                                 $forName('java.lang.Object')
                                 $getMethods()))) ==
              c("hashCode",
                "getClass",
                "wait",
                "equals",
                "notify",
                "notifyAll",
                "toString"))
  #+END_SRC
* DONE ~setJavaInterfaceImplementation~ with dollars
  CLOSED: [2011-05-10 Tue 22:50]
  #+BEGIN_SRC R :tangle test-interface.R :noweb yes :shebang #!/usr/local/bin/R --vanilla --slave -f
    <<preamble>>
    
    dollarsToJava <- function(refClass, method)
      toJava(do.call(`$`, list(refClass, method)))
    
    testInterfaceProxy <- function(interface, implementation)
      new(J('TestInterfaceProxy'),
          interface,
          toJava(dollarsToJava),
          toJava(implementation))$newInstance()
    
    setJavaInterfaceImplementation <- function(interface,
                                               implementation)
      setRefClass('jobjInterfaceRef',
                  contains=implementation@.xData$.refClassDef@className,
                  fields='proxy',
                  methods=list(initialize=eval(substitute(function() {
                    proxy <<-
                      testInterfaceProxy(interface, implementation)
                    .self
                  }),
                                 list(interface=interface,
                                      implementation=implementation))))
    
    testInterfaceImplementation <-
      setRefClass('testInterfaceImplementation',
                  methods=list(salute=function(salutandum)
                    sprintf('Salve, %s!', salutandum)))
    
    testInterface <-
      setJavaInterfaceImplementation('TestInterfaceProxyInterface',
                                     testInterfaceImplementation$new())
    
    ti <- testInterface$new()
    
    stopifnot(ti$salute('terra') == ti$proxy$salute('terra'))
    
  #+END_SRC
  
  #+BEGIN_SRC java :tangle src/TestInterfaceProxy.java
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Set;
    
    import org.rosuda.REngine.RList;
    import org.rosuda.REngine.REngine;
    import org.rosuda.REngine.REXP;
    import org.rosuda.REngine.REXPDouble;
    import org.rosuda.REngine.REXPInteger;
    import org.rosuda.REngine.REXPFactor;
    import org.rosuda.REngine.REXPLanguage;
    import org.rosuda.REngine.REXPList;
    import org.rosuda.REngine.REXPRaw;
    import org.rosuda.REngine.REXPReference;
    import org.rosuda.REngine.REXPString;
    import org.rosuda.REngine.REXPWrapper;
    import org.rosuda.REngine.REXPJavaReference;
    import org.rosuda.REngine.JRI.JRIEngine;
    
    public class TestInterfaceProxy {
        String interfaceName;
        REXPReference dollars;
        REXPReference refClass;
        InvocationHandler handler;
        static HashMap<Class, Method> translators;
    
        public TestInterfaceProxy(String interfaceName,
                                  REXPReference dollars,
                                  REXPReference refClass) {
            this.interfaceName = interfaceName;
            this.dollars = dollars;
            this.refClass = refClass;
            this.handler = makeInvocationHandler();
        }
    
        static {
            try {
                translators =
                    new HashMap<Class, Method>() {
                    {
                        put(REXPString.class,
                            REXPString.class.getMethod("asString"));
                        put(REXPRaw.class,
                            REXPRaw.class.getMethod("asBytes"));
                        put(REXPDouble.class,
                            REXPDouble.class.getMethod("asDouble"));
                        put(REXPFactor.class,
                            REXPFactor.class.getMethod("asFactor"));
                        put(REXPInteger.class,
                            REXPInteger.class.getMethod("asInteger"));
                        put(REXPList.class,
                            REXPList.class.getMethod("asList"));                    
                    }
                };
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
    
        public InvocationHandler makeInvocationHandler() {
            return new InvocationHandler() {
                public Object invoke(Object proxy,
                                     Method method,
                                     final Object[] args) {
                    try {
                        final REXPReference refClassMethod = (REXPReference)
                            ((REXPJavaReference)
                             ((REXPReference) dollars).getEngine()
                             .eval(new REXPLanguage
                                   (new RList(new REXP[] {
                                           dollars,
                                           refClass,
                                           new REXPString(method.getName())
                                       })),
                                   null,
                                   true))
                            .getObject();
    
                        ArrayList<REXP> call = new ArrayList<REXP>() {
                            {
                                add(refClassMethod);
                                if (args != null) {
                                    for (Object arg: args) {
                                        REXP wrappedArg = REXPWrapper.wrap(arg);
                                        if (wrappedArg != null)
                                            add(wrappedArg);
                                        else
                                            // Last-ditched attempt to add
                                            // a non-scalar
                                            add(new REXPJavaReference(arg));
                                    }
                                }
                            }
                        };
    
                        REXP value = refClassMethod.getEngine()
                            .eval(new REXPLanguage
                                  (new RList(
                                             call.toArray(new REXP[0])
                                             // new REXP[] { refClassMethod }
                                             )),
                                  null,
                                  true);
    
                        if (value instanceof REXPJavaReference)
                            return ((REXPJavaReference) value).getObject();
                        else {
                            Method translator = TestInterfaceProxy.translators
                                .get(value.getClass());
                            if (translator != null)
                                return translator.invoke(value);
                            else
                                return null;
                        }
                    } catch (Throwable e) {
                        e.printStackTrace();
                    }
                    return null;
                }
            };
        }
    
        public Object newInstance() {
            try {
                Class interfaceClass = Class.forName(interfaceName);
                return Proxy.newProxyInstance(interfaceClass.getClassLoader(),
                                              new Class[] { interfaceClass },
                                              handler);
            } catch (Throwable e) {
                e.printStackTrace();
            }
    
            return null;
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC java :tangle src/TestInterfaceProxyInterface.java
    public interface TestInterfaceProxyInterface {
        public String salute(String salutandum);
    }
    
  #+END_SRC

  #+BEGIN_SRC makefile :tangle test-interface.mk :shebang #!/usr/bin/unexpand -t 4
    all:
        $(MAKE) -C src all TestInterfaceProxy.class && \
        ./test-interface.R
    
  #+END_SRC
* DONE dollars
  CLOSED: [2011-05-10 Tue 21:47]
  signature: ~RInterfaceProxy(String interfaceName, REXPReference
  refClass, REXPReference dollars)~; in ~invoke(Object proxy, Method
  method, final Object[] args)~, ~method.getName()~ takes the place of
  ~String method~ in ~TestCallableReturn.test~.

  ~setJavaInterfaceImplemntation(interface, implementation)~ (using
  ~substitute~); when instantiating ~RInterfaceProxy~, it uses
  ~dollarsToJava~. is there any way we can pull ~dollarsToJava~ out of
  the package/environment?

  it's merely convenient, of course, to pass it in; can we justify it
  by abstracting the accessor? don't think so.
* DONE =setJavaInterfaceImplementation=
  CLOSED: [2011-05-10 Tue 21:47]
  - CLOSING NOTE [2011-05-10 Tue 21:47] \\
    Pre-dollars
# <<setJavaInterfaceImplementation>>
  because of the limitations of closures and refclasses, have to
  repeat the implementation in both =setJII= *and* the constructor;
  for other opaque reasons, cannot both subclass =jobjRef= and specify
  an initializer.
  
  use michael's idea of [[substitute][substitute on the function definition]].

  bad news, btw: =.self= and =callSuper= don't exist when calling from
  java.

  #+BEGIN_SRC R :noweb yes :tangle test-short-circuit.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    options(morePaths='tests')
    
    library(rJavax)
    
    setJavaInterfaceImplementation <- function(implementation)
      setRefClass('jobjInterfaceRef',
                  contains=implementation$className,
                  fields='proxy',
                  methods=list(initialize=function(interface,
                                 implementation,
                                 ...) {
                    implementations <-
                      structure(Map(function(name) {
                        get(name, implementation$def@refMethods)
                      },
                                    implementation$methods()),
                                names=implementation$methods())
                    proxy <<-
                      interfaceProxy(interface, implementations)
                    .self
                  }))
    
    testInterfaceImplementation <-
      setRefClass('testInterfaceImplementation',
                  methods=list(mogrify=function(string)
                    paste(string, 'mogrified', sep='-'),
                    tetradicSum=function(w, x, y, z)
                    sum(w, x, y, z),
                    multiplyInts=function(x, y)
                    as.integer(x * y)))
    
    testInterface <-
      setJavaInterfaceImplementation(testInterfaceImplementation)
    
    ti <- testInterface$new('TestInterface',
                            testInterfaceImplementation)
    
    stopifnot(ti$mogrify('test') == ti$proxy$mogrify('test'))
    
  #+END_SRC  

  example of =RcreateObject= on =RInterfaceProxy=:

  #+BEGIN_SRC R
    new('jobjRef',
        jobj=.External('RcreateObject',
          'RInterfaceProxy',
          'TestInterface',
          to.hashmap(list(mogrify=function(string)
                          paste(string, 'mogrified', sep='-'),
                          tetradicSum=function(w, x, y, z)
                          sum(w, x, y, z),
                          multiplyInts=function(x, y)
                          as.integer(x * y)))),
        jclass='RInterfaceProxy')$newInstance()$tetradicSum(1, 2, 3, 4)
  #+END_SRC
* DONE call the result of an R function
  CLOSED: [2011-05-04 Wed 03:00]
  - CLOSING NOTE [2011-05-04 Wed 03:00] \\
    Done even for the reference class case
  #+BEGIN_SRC java :tangle src/TestCallableReturn.java
    import org.rosuda.REngine.RList;
    import org.rosuda.REngine.REngine;
    import org.rosuda.REngine.REXP;
    import org.rosuda.REngine.REXPEnvironment;
    import org.rosuda.REngine.REXPLanguage;
    import org.rosuda.REngine.REXPReference;
    import org.rosuda.REngine.REXPString;
    import org.rosuda.REngine.REXPUnknown;
    import org.rosuda.REngine.REXPJavaReference;
    
    public class TestCallableReturn {
        public static void test(REXPReference dollars,
                                REXPReference refClass,
                                String method) {
            try {
                // We can also get at the method followingly; but we run
                // into the problem that it is not a REXPReference and
                // therefore cannot, apparently, be evaluated:
                // 
                // System.out.println(((REXPEnvironment) refClass.getAttribute(".xData"))
                //                    .get("test"));
    
                REXPReference refClassMethod = (REXPReference)
                    ((REXPJavaReference)
                     ((REXPReference) dollars).getEngine()
                     .eval(new REXPLanguage
                           (new RList(new REXP[] { dollars,
                                                   refClass,
                                                   new REXPString(method) })),
                           null,
                           true))
                    .getObject();
    
                REXP value = refClassMethod.getEngine()
                    .eval(new REXPLanguage
                          (new RList(new REXP[] { refClassMethod })),
                          null,
                          true);
    
                // Would be nice if we could actually extract callable
                // methods this way.
                assert ((REXPUnknown)
                        ((REXPEnvironment)
                         value.getAttribute(".xData")).get("test")).getType()
                    == 3;
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC R :tangle test-callable-return.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    
    .jinit(classpath='inst/java/JRIEngine.jar:inst/java/JRI.jar:inst/java/REngine.jar:inst/java/rJavax.jar:src')
    .jengine(TRUE)
    
    dollarsToJava <- function(refClass, method)
      toJava(do.call(`$`, list(refClass, method)))
    
    testClass <- setRefClass('testClass',
                             ## We can refer to .self even in Java!
                             methods=list(test=function() .self))
    
    J('TestCallableReturn')$test(toJava(dollarsToJava),
                                 toJava(testClass$new()),
                                 'test')
    
  #+END_SRC

  #+BEGIN_SRC makefile :tangle test-callable-return.mk :shebang #!/usr/bin/unexpand -t 4
    all:
        make -C src all TestCallableReturn.class &&
        ./test-callable-return.R

  #+END_SRC
  
  [[http://www.rforge.net/org/docs/org/rosuda/REngine/REXPEnvironment.html][REXPEnvironment]]s are like REXPReferences, btw; so we may not need to
  ~toJava~ everything? Instead of calling ~$~, it looks like we may be
  able to do ~REXPReference.get~. Oh: but we have that whole ~toJava~
  business; should we override ~$~? But we want the short-circuit
  case.

  Also, reference classes don't appear to come back as environments;
  but as lists instead (with ~.xData~, etc.). Nope; not ~RList~ nor
  ~REXPList~, neither.

  Well, regardless: we can reference ~.self~.
* DONE =getObject=
  CLOSED: [2011-05-04 Wed 03:00]
  test ~value.getObject~ à la [[simons-letter][simon's letter]]; he must be referring to
  [[http://www.rforge.net/org/docs/org/rosuda/REngine/REXPJavaReference.html][REXPJavaReference]], mustn't he: but how to get one?

  i don't want to force people on the R-side to have to wrap their
  values.

  #+BEGIN_SRC java :tangle src/TestArbitraryObject.java
    import java.util.Stack;
    
    public interface TestArbitraryObject {
        public Stack stack(Stack stack);
    }
  #+END_SRC

  should we abstract this ~.jinit~ prologue into a named block?

  #+BEGIN_SRC R :tangle test-arbitrary-object.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    source('R/interface.R')
    
    .jinit(classpath='inst/java/JRIEngine.jar:inst/java/JRI.jar:inst/java/REngine.jar:inst/java/rJavax.jar:src')
    .jengine(TRUE)
    
    interface <-
      interfaceProxy('TestArbitraryObject',
                     list(stack=function(stack) stack,
                          toString=function() 'TestArbitraryObject'))
    
    interface$stack(new(J('java/util/Stack')))
    
  #+END_SRC

  #+BEGIN_SRC makefile :tangle test-arbitrary-object.mk :shebang #!/usr/bin/unexpand -t 4
    all:
        make -C src all TestArbitraryObject.class && ./test-arbitrary-object.R
  #+END_SRC
* DONE ~ld.so.conf~
  CLOSED: [2011-04-25 Mon 02:35]
  i have to add at least these two directories (pointing to
  ~libjvm.so~ and ~rJava.so~:

  #+BEGIN_EXAMPLE
  /usr/local/java/jre/lib/amd64/server/
  /usr/local/lib64/R/library/rJava/libs
  #+END_EXAMPLE
* DONE ~REXPJavaReference~
  CLOSED: [2011-04-25 Mon 02:24]
  - CLOSING NOTE [2011-04-25 Mon 02:25] \\
    http://www.rforge.net/JRI/files/
  all of our jars appear to be defective.
  
  #+BEGIN_SRC java :tangle src/TestREXPJavaReference.java
    import org.rosuda.REngine.REXPJavaReference;
    
    public class TestREXPJavaReference {
        public static void main(String[] argv) {
        }
    }
    
  #+END_SRC
* DONE package preamble for testing
  CLOSED: [2011-04-13 Wed 12:38]
  #+srcname: preamble
  #+BEGIN_SRC R
    library(rJava)
    source('R/interface.R')
    
    .jinit(classpath=paste(c(Sys.glob('inst/java/*.jar'), 'src', 'tests'),
             collapse=':'))
    .jengine(TRUE)
    
  #+END_SRC
* DONE reference class inheriting from =jobjRef=
  CLOSED: [2011-04-13 Wed 12:38]
  #+BEGIN_SRC R :noweb yes :tangle test-inheritance.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    <<preamble>>
    
    ir <- setRefClass('jobjInterfaceRef', contains='jobjRef')
    
    ir$new(jobj=.External('RcreateObject', 'java/lang/Object', PACKAGE='rJava'),
           jclass='java/lang/Object')
    
  #+END_SRC
* DONE R package
  CLOSED: [2011-04-11 Mon 05:50]
  - CLOSING NOTE [2011-04-11 Mon 05:51] \\
    used =helloJavaWorld= as prototype; abusing the top-level =src=
    directory for Java: questionable? also, we're generating rJava.jar
    during installation, whereas =helloJavaWorld= and co. just check
    in the binary jars.
  this seems vaguely relevant, but i'm not sure how (from [[http.://cran.r-project.org/doc/manuals/R-exts.pdf][R-exts.pdf]]):

  #+BEGIN_QUOTE
  In some rare circumstances, the configuration and cleanup scripts
  need to know the location into which the package is being
  installed. An example of this is a package that uses C code and
  creates two shared object/DLLs. Usually, the object that is
  dynamically loaded by R is linked against the second, dependent,
  object. On some systems, we can add the location of this dependent
  object to the object that is dynamically loaded by R. This means
  that each user does not have to set the value of the
  =LD_LIBRARY_PATH= (or equivalent) environment variable, but that the
  secondary object is automatically resolved. Another example is when
  a package installs support files that are required at run time, and
  their location is substituted into an R data structure at
  installation time. (This happens with the Java Archive files in the
  SJava package.) The names of the top-level library directory (i.e.,
  specifiable via the =‘-l’= argument) and the directory of the
  package itself are made available to the installation scripts via
  the two shell/environment variables =R_LIBRARY_DIR= and
  =R_PACKAGE_DIR=. Additionally, the name of the package
  (e.g. =‘survival’= or =‘MASS’=) being installed is available from
  the environment variable =R_PACKAGE_NAME=. (Currently the value of
  =R_PACKAGE_DIR= is always =${R_LIBRARY_DIR}/${R_ PACKAGE_NAME}=, but
  this used not to be the case when versioned installs were
  allowed. Its main use is in =‘configure.win’= scripts for the
  installation path of external software’s DLLs.)
  #+END_QUOTE
 
  we're going to have to do a =configure.ac=, which does
  =AC_SUBST(...)= and =AC_CONFIG_FILES([...R])= to formalize
  =CLASSPATH=, =JAVA_LIBRARY_PATH=; as well as some kind of shell
  script to invoke =R= properly, which formalizes =LD_LIBRARY_PATH=.

  we're going to have to abuse =src= to build =RInterfaceProxy.jar=;
  let's do it over =Makefile=, possibly via =configure.ac= (and not,
  say, =ant=).

* DONE pass values to interface-methods
  CLOSED: [2011-04-04 Mon 03:30]
  - CLOSING NOTE [2011-04-04 Mon 03:30] \\
    works for some native types; not yet, however, for arbitrary classes.
  there are some mixups, somehow, while translating between Java and
  R.
* DONE return values from invocation-handler
  CLOSED: [2011-03-30 Wed 06:10]
  - CLOSING NOTE [2011-03-30 Wed 06:10] \\
    this doesn't work for the given example, of course, because the
    interface-method returns =void=!
* DONE register R-functions with a Java-proxy
  CLOSED: [2011-03-30 Wed 05:42]
  - CLOSING NOTE [2011-03-30 Wed 05:43] \\
    couple weirdnesses: can't preserve =REXPReferences= via =toJava= in
    named lists (though converting to vectors over =.jarray=); resorted,
    therefore, to a =HashMap=.
    
    also, can't return anything but =null= from the =InvocationHandler=.
  #+BEGIN_SRC R :tangle test-mogrifier.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit(classpath=Sys.getenv('CLASSPATH'),
           parameters=sprintf('-Djava.library.path=%s',
             Sys.getenv('JAVA_LIBRARY_PATH')))
    .jengine(TRUE)
    
    merge.lists <- function(...) {
      list = do.call(c, list(...))
      list[unique(names(do.call(c, list)))]
    }
    
    to.hashmap <- function(implementations) {
      hashmap <- new(J('java.util.HashMap'))
    
      ## Some things that Java expects of Objects.
      default.implementations <- list(toString=function()
                                      "RInterfaceProxy")
    
      implementations <-
        merge.lists(implementations,
                    default.implementations)
      
      ## Really need a Foreach here, since we're not using the return
      ## value.
      Map(function(name, implementation)
          hashmap$put(name, toJava(implementation)),
          names(implementations),
          implementations)
      hashmap
    }
    
    proxy <- new(J('RInterfaceProxy'),
      'Mogrifier',
      to.hashmap(list(mogrify=function(string)
                      paste(string, 'mogrified', sep='-'),
                      tetradicSum=function(w, x, y, z)
                      sum(w, x, y, z),
                      multiplyInts=function(x, y)
                      as.integer(x * y))))
    
    mogrifier <- proxy$newInstance()
    
    stopifnot(mogrifier$mogrify('totally') == 'totally-mogrified')
    
    stopifnot(mogrifier$tetradicSum(1, 2, 3, 4) == 10)
    
    stopifnot(mogrifier$multiplyInts(as.integer(2), as.integer(4)) == 8)
    
  #+END_SRC

  #+BEGIN_SRC java :tangle RInterfaceProxy.java
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Set;
    
    import org.rosuda.REngine.RList;
    import org.rosuda.REngine.REngine;
    import org.rosuda.REngine.REXP;
    import org.rosuda.REngine.REXPDouble;
    import org.rosuda.REngine.REXPInteger;
    import org.rosuda.REngine.REXPFactor;
    import org.rosuda.REngine.REXPLanguage;
    import org.rosuda.REngine.REXPList;
    import org.rosuda.REngine.REXPRaw;
    import org.rosuda.REngine.REXPReference;
    import org.rosuda.REngine.REXPString;
    import org.rosuda.REngine.REXPWrapper;
    import org.rosuda.REngine.JRI.JRIEngine;
    
    public class RInterfaceProxy {
        String interfaceName;
        HashMap<String, REXPReference> implementations;
        InvocationHandler handler;
        static HashMap<Class, Method> translations;
    
        public RInterfaceProxy(String interfaceName,
                               HashMap<String, REXPReference> implementations) {
            this.interfaceName = interfaceName;
            this.implementations = implementations;
            this.handler = makeInvocationHandler();
        }
    
        static {
            try {
                translations =
                    new HashMap<Class, Method>() {
                    {
                        put(REXPString.class,
                            REXPString.class.getMethod("asString"));
                        put(REXPRaw.class,
                            REXPRaw.class.getMethod("asBytes"));
                        put(REXPDouble.class,
                            REXPDouble.class.getMethod("asDouble"));
                        put(REXPFactor.class,
                            REXPFactor.class.getMethod("asFactor"));
                        put(REXPInteger.class,
                            REXPInteger.class.getMethod("asInteger"));
                        put(REXPList.class,
                            REXPList.class.getMethod("asList"));                    
                    }
                };
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
    
        public InvocationHandler makeInvocationHandler() {
            return new InvocationHandler() {
                public Object invoke(Object proxy,
                                     Method method,
                                     final Object[] args) {
                    try {
                        final REXPReference implementation =
                            RInterfaceProxy.this.implementations
                            .get(method.getName());
                        ArrayList<REXP> call = new ArrayList<REXP>() {
                            {
                                add(implementation);
                                for (Object arg: args) {
                                    add(REXPWrapper.wrap(arg));
                                }
                            }
                        };
                        REXP value = implementation.getEngine()
                            .eval(new REXPLanguage
                                  (new RList (call.toArray(new REXP[0]))),
                                null,
                                true);
                        // NB: need to handle the case where get returns
                        // null.
                        return RInterfaceProxy.translations
                            .get(value.getClass()).invoke(value);
                    } catch (Throwable e) {
                        e.printStackTrace();
                    }
                    return null;
                }
            };
        }
    
        public Object newInstance() {
            try {
                Class interfaceClass = Class.forName(interfaceName);
                return Proxy.newProxyInstance(interfaceClass.getClassLoader(),
                                              new Class[] { interfaceClass },
                                              handler);
            } catch (Throwable e) {
                e.printStackTrace();
            }
    
            return null;
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC java :tangle Mogrifier.java
    import org.rosuda.REngine.REXP;
    
    public interface Mogrifier {
        public String mogrify(String string);
        public double tetradicSum(double w, double x, double y, double z);
        public int multiplyInts(int x, int y);
    }
    
  #+END_SRC
* DONE calling a java function (given a class) from within rJava
  CLOSED: [2011-03-30 Wed 02:32]
  - CLOSING NOTE [2011-03-30 Wed 02:33] \\
    requires, however, a non-trivial environment (see [[./Makefile][Makefile]]).
  #+BEGIN_SRC java :tangle TrivialFunction.java
    public class TrivialFunction {
        public void trivialFunction() {
            System.out.println("hello, pseudo-trivial world!");
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC R :tangle test-java-function.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit(classpath=Sys.getenv('CLASSPATH'),
           parameters=sprintf('-Djava.library.path=%s',
             Sys.getenv('JAVA_LIBRARY_PATH')))
    tf = .jnew('TrivialFunction')
    .jcall(tf, 'V', 'trivialFunction')
    
  #+END_SRC
* DONE dispatch on proxy-method (Java) -> implementation-method (R) dictionary
  CLOSED: [2011-03-30 Wed 05:43]
  this will require a call from R to Java to the effect of: this named
  list of procedures implements that interface.

  see [[notes-2011-03-28][notes]].
* DONE example of a proxy
  CLOSED: [2011-03-28 Mon 09:40]
  #+BEGIN_SRC java :tangle TestInterfaceProxy.java
    import java.lang.StringBuilder;
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.util.Formatter;
    
    import org.rosuda.REngine.JRI.JRIEngine;
    import org.rosuda.REngine.REngine;
    import org.rosuda.REngine.REngineStdOutput;
    
    import org.apache.commons.lang3.RandomStringUtils;
    
    interface A {
        String b(String c, String d);
    }
    
    class TestInterfaceProxy {
        static REngine re;
    
        public static void main(String[] argv) throws Throwable {
            InvocationHandler handler = new InvocationHandler() {
                    public Object invoke(Object proxy,
                                         Method method,
                                         Object[] args) {
                        try {
                            StringBuilder evalArgs = new StringBuilder();
                            for (Object arg: args) {
                                // http://stackoverflow.com/questions/41107/how-to-generate-a-random-alpha-numeric-string-in-java
                                String identifier = RandomStringUtils.randomAlphabetic(32);
                                // http://tolstoy.newcastle.edu.au/R/help/04/04/0847.html
                                re.assign(identifier, (String) arg);
                                evalArgs.append(identifier);
                                evalArgs.append(",");
                            };
                            if (evalArgs.length() > 0)
                                evalArgs.deleteCharAt(evalArgs.length() - 1);
                            return re.parseAndEval(String.format("%s(%s)",
                                                                 method.getName(),
                                                                 evalArgs)).asString();
                        } catch (Throwable e) {
                            e.printStackTrace();
                            // re.end();
                        }
                        System.out.println(method);
                        return new Object();
                    };
                };
            A a = (A) Proxy.newProxyInstance(A.class.getClassLoader(),
                                             new Class[] { A.class },
                                             handler);
            
            re = JRIEngine.createEngine(new String[] { "--vanilla", "--slave" },
                                        new REngineStdOutput(),
                                        false);
    
            re.parseAndEval("b <- function(c, d) paste(c, d)");
     
            assert a.b("hello", "world").equals("hello world");
     
            re.close();
        }
    }
  #+END_SRC
* CANCELED refclass with ~bQuote~
  CLOSED: [2011-05-10 Tue 20:52]
  - CLOSING NOTE [2011-05-10 Tue 20:53] \\
    Can't make bquote work with more complicated examples (e.g. nested
    functions); falling back on ~substitute~.
  #+BEGIN_SRC R :tangle refclass-with-bquote.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    make.ref.class <- function(a)
      setRefClass('b',
                  methods=list(initialize=eval(bquote(function() {
                    print(.(a))
                    .self
                  }))));
    
    A <- make.ref.class(2)
    a <- A$new()
  #+END_SRC
* CANCELED implementations as reference classes instead of lists
  CLOSED: [2011-05-04 Wed 03:01]
  - CLOSING NOTE [2011-05-04 Wed 03:01] \\
    See [[setJavaInterfaceImplementation]].
  from [[http://stat.ethz.ch/R-manual/R-devel/library/methods/html/refClass.html][refClass]]:

  #+BEGIN_QUOTE
  Fields may be modified in a method by using the non-local assignment
  operator, =<<-=.

  The call to setRefClass defines the specified class and returns a
  “generator” object for that class.

  - =$new(...)= :: This method is equivalent to the function new with
                   the class name as an argument. The =...= arguments
                   are values for the named fields. If the class has a
                   method defined for =$initialize()=, this method
                   will be called once the reference object has been
                   created.
                   
                   The default method for =$initialize()= is
                   equivalent to invoking the method
                   =$initFields(...)= with named fields as its
                   arguments.
  #+END_QUOTE

  see [[http://dirk.eddelbuettel.com/blog/2010/10/15/][dirk's blog]]:

  #+BEGIN_QUOTE
  new =Rcpp::Reference= class, that allows internal manipulation of R
  2.12.0 reference classes. The class exposes a constructor that takes
  the name of the target reference class and a field(string) method
  that implements the proxy pattern to get/set reference fields using
  callbacks to the R operators =$= and =$<-= in order to preserve the
  R-level encapsulation.
  #+END_QUOTE
* Notes
** Mon Mar 28 10:50:13 PDT 2011
# <<notes-2011-03-28>>
   we'll have the REXPs corresponding to closures; look at
   =Rengine.Rengine= not =JRI.Rengine=; we'll have a list of REXPs.

   register list of functions, state saved in InvocationHandler; give
   as a return value IH; return an IH whose constructor takes the
   dictionary; custom java code implementing IH; class generator in
   reference class, wrapper around invocation handler.

   implementInterface, pass dictionary: get constructor or
   implementation handler; return the closure, if they call the
   closure, they get an object; think about state at some point.

   list of methods declared in the interface.
** Mon Apr  4 10:22:25 PDT 2011
   build our own JRI class with appropriate slots; create S4 objects:
   special call in C.

   wrap it in R package; test suite; reference class; nice interface.

   generator object: setRefClass; initialize method on class; every
   reference object reference to java object that underlies it;
   initialize method: sets up reference; wrapper methods for each
   method in interface; send to setRefClass; fields: active bindings;
   setRefClass gives back class generator; use normal reference class
   api to construct objects.

   setRefClass for any interface, class; given a reference to a java
   object; instantiate reference class, have underlying java
   object. more general than implementing of interfaces; any interface
   has an equivalent refClass.

   don't have a named class yet; define a new interface: gives them
   back a reference; interface has been pre-defined by java; maintain:
   class-name map; interface implementation, gives them back reference
   generator object; wrappers could be shared across class, interface;
   difference is in initialize method;

   related but orthogonal: wrapJavaClass, proxyJavaClass; for any
   named class: can get a generator; call directly from R, not Java.

   initialize function: does what that closure what do: calls the
   proxy method; generalize it, though, so that we can proxy any java
   class; .jnew on the named class; allowing it to take a function in
   the constructor; what does the constructor do? sort of like the
   initialize method: instance exists, initializes instance.

   get a java object from initialize: pass to constructor/initializer;
   override initialization: can take arguments, fields.

   fancy: custom initializers.
** Mon Apr 11 10:13:54 PDT 2011
   implement not only interfaces but classes; worry about fields
   later; methods wrappers for .jcall, etc.; initialize()
   constructor. methods on the reference class just R functions
   themselves?

   right now: list, expect them to be called from java; instead of
   calling java to call R; instead: use functions directly as methods;
   for calling things from R, short circuit it by calling the
   implementation methods directly; pass it directly to the
   =setRefClass= call (=methods=); once it's =setRefClass=, semantics
   are somewhat different (not necessarily drop-in); if implementing
   java interface, want to use those features anyway; if something is
   called from java, will it work if it uses these reference class
   features; right enclosure; they parse methods with codetools; need
   to make sure: same function; enclosing environment hasn't
   changed. need to make sure that the function called from java is
   the same function as called directly; people want the ability to be
   able to say, this, self, and have things work correctly; if were
   not doing this, self; pass methods into setRefClass and get
   something corresponding to that function back out; own version of
   the method enclosed in that instance environment;

   when i implement this: closures? need some kind of mutable
   state. how would that work with a single closure per class; static
   state vs. class-level state; support instance-level state;

   setRefClass: implement function? proxy refClass for classes *or*
   interfaces; reference classes for extensions of java; c++:
   extensions of c++ classes in R, c++ cannot see the R
   implementations; what we'd like to do: at least at the interface
   level, have java see the R implementation;

   should they be writing code in the reference class style? (pretty
   compatible with java, etc.)

   discrete steps: 1. setRefClass, 2. implements interface; needs to
   be able to get the methods enclosed in the instance; different set
   of functions for every instance; create a new invocation handler
   instance in initialize(); setJavaReferenceClass? given a java
   class, create corresponding reference class; rcpp: allows them to
   add on new methods; setRefClass call; that's where the
   introspection comes in in initialization(); interfaces only
   supported through java Proxy; currently only interfaces; later
   class; give setJavaReferenceClass a list of character vectors
   naming all the interfaces you want to implement; for now, single
   interface; in the multiple interface case: methods() would be a
   list of lists; conflicting method names in multiple interface
   implementation; setJavaReferenceClass is a wrapper around
   setRefClass: given name of java class or opaque class object,
   introspect it, come up with a bunch of stubs that delegate up
   through the rjava interface; setJavaImplementation; if the class
   doesn't exist yet; if we want it to mimic java, how far do you go?;
   at least need to represent all the parent classes of a given
   object; represent e.g. java.lang.Object as reference class when
   reference-classing java.lang.reflect.Proxy;

   just make it work with the interfaces we've implemented? rJava
   already similar to reference classes ($, etc.): what is the
   advantages to these proxies? rcpp, same playing field, etc.;
   correct about it: lot of overhead; trying to mimic rcpp, write cpp
   in package, want to be able to call them from R via reference
   classes; qt cpp stuff released in about a month through
   bioconductor; not much point to a reference class if not
   bidirectional; decide to what extent we're going to do the mapping;
   introspecting entire class hierarchy not practical;

   reference class stuff for this interface stuff;
   setJavaInterfaceImplementation: name of interface, list of methods
   (weren't going to do short-circuiting);

   setJavaInterfaceImplementation: name, list of methods; from name,
   look up ref class; inherit from that class; for implementations:
   pass to java, inherited proxy methods, into location handler; other
   way: short circuit; override methods with our implementations; call
   these things directly from within R; during initialize methods, go
   in get methods out, pass them on to invocation handler; setJII:
   calls setRefClass, initialize(): get the methods out of the
   instance, take them and pass them to the constructor of the proxy;
   make it so that we can get from reference class object the
   corresponding java object (jObjRef); every one of these guys should
   inherit from some base references class that has a method to access
   the jObjRef; somehow access generator object; test: short-circuited
   call from within R, long route through java; translate between two
   representations; 

   all of our reference classes inherit from jObjRef; has the
   necessary slots; pass that as any java interface transparently;
   reference class inherit from S4; 
** Wed Apr 13 14:09:14 PDT 2011
   =initialize()= calls constructor on java object; just copy the
   =jobj= and the =jclass= slots.

   =com.gene.bioinfo.R=

   mimic what john did with Rcpp; 
** Mon Apr 18 10:10:59 PDT 2011
   every java interface or class: has a reference class version of it;
   signify instance, every java superclass; stub java implementations
   that merely call the java methods, except where overridden;
   contains: names of classes; all the parent-implementing R classes
   as a flat list in the ;

   contains: all the interfaces that it implements and its parent
   implementations; trace the interfaces up to parentlessness;

   fields support active bindings; construct an active binding;
   substitute on the body; jobjRef, subinterface, multiple interface.

# <<substitute>>
   substitute outside the function definition.
** Wed Apr 20 13:08:00 PDT 2011
# <<simons-letter>>
   got this letter from simon:

   #+BEGIN_EXAMPLE
   Subject: Re: Accessing the robjRefs that underlie REXPS4/REXPReferences
   From: Simon Urbanek
   Date: Tue, 19 Apr 2011 23:09:52 -0400
   Cc: Michael Lawrence, Nicholas Lewin-Koh
   To: Peter Danenberg

   > If we have to modify rJava at the JNI level in order to retrieve
   > objects not supported by e.g. REXPWrapper, do you mind giving us
   > a hint?

   You don't need to modify anything at JNI level because it's all
   there ;). I was very busy in the last weeks and it was not trivial
   to figure out what you're actually up to so I didn't get to it (all
   you really wanted is Java reference support in resolveObject()).

   Short story: get the most recent rJava and this will work: Object
   foo = value.getObject();

   The long story is that rni.rniXrefToJava() is what you wanted to
   use, but since EXTPTRSXP was not supported in the resolution
   (leading to null result and thus no attribute) you could not do it
   on the resolved object. For now I have added a static support for
   jobjRef objects in JRIEngine.resolvePointer() so they get converted
   into REXPJavaReference. In the long run I'm envisioning a registry
   of R classes so you can register a convertor that will get the
   resolved REXP, the pointer and the engine so it can fill any
   missing holes - and that could be used by packages as well.

   Cheers,
   Simon

   > getAttribute("jobj") comes up null, unfortunately, on REXPS4s.
   #+END_EXAMPLE

   ascend the interface hierarchy to determine whether the
   implementation is complete; these things virtual, no one
   instantiate directly. error if it hasn't been implemented.
   
   problem is more general: have to provide implementation for every
   method; implement an interface, has to extend, at least,
   ~java.lang.object~;

   dummy object; fake the inheritance from ~java.lang.Object~;
   ~finalize~: free some SEXPs? (two garbage collectors); ~getClass~:
   return ~java.lang.Object~; ~clone~: how to clone state?; ~notify~,
   ~wait~: dummy object to keep track of that state; just clone the
   pointer? copy the environment that stores the reference class;
   reference to other environments, etc. that aren't copy; forward the
   clone call onto the reference class object; shallow copy; java, by
   default, does a shallow copy on the fields; expect the user to
   override ~clone~ if they need a deep copy of the environment.

   dummy object to handle signaling; 1) simon's new code; 2)
   object; 3) reference class stuff.

   subclassing difficult: can't extend a class; can only implement
   interfaces; but try to support defining proxies of java classes as
   reference classes; now integrated with S4 dispatch; whereas before,
   attach to =jobjRef=; like Rcpp with a limited subset of
   bidirectionality: interfaces.
** Mon Apr 25 10:10:01 PDT 2011
   functions modified and closed so that refclass methods see this and
   super; ~.self~ and ~callSuper~ cease to exist; because we call the
   function directly; call it through the reference class; create the
   new object, instantiate the reference class; construct instance
   first; get ~.self~ and ~callSuper~ out of the initialize
   environment; rather than get from the implementation, just get from
   the environment; print out what the enclosing environment during
   and after initialization; slightly promiscuous: call it from java
   on the reference class, as opposed to the naked methods; 
** Wed May  4 14:03:29 PDT 2011
   bioconductor conference; poster-worthy stuff; get the
   proxy-object-class working; integrated into a nice package; IGB by
   the end of the month.
