# -*- org -*-
#+TITLE: Only a C++ hacker could have come up with Reference Classes.
* TODO =setJavaInterfaceImplementation=
  because of the limitations of closures and refclasses, have to
  repeat the implementation in both =setJII= *and* the constructor;
  for other opaque reasons, cannot both subclass =jobjRef= and specify
  an initializer.
  
  bad news, btw: =.self= and =callSuper= don't exist when calling from
  java.

  #+BEGIN_SRC R :noweb yes :tangle test-short-circuit.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    options(morePaths='tests')
    
    library(rJavax)
    
    setJavaInterfaceImplementation <- function(implementation)
      setRefClass('jobjInterfaceRef',
                  contains=implementation$className,
                  fields='proxy',
                  methods=list(initialize=function(interface,
                                 implementation,
                                 ...) {
                    implementations <-
                      structure(Map(function(name) {
                        get(name, implementation$def@refMethods)
                      },
                                    implementation$methods()),
                                names=implementation$methods())
                    proxy <<-
                      interfaceProxy(interface, implementations)
                    .self
                  }))
    
    testInterfaceImplementation <-
      setRefClass('testInterfaceImplementation',
                  methods=list(mogrify=function(string)
                    paste(string, 'mogrified', sep='-'),
                    tetradicSum=function(w, x, y, z)
                    sum(w, x, y, z),
                    multiplyInts=function(x, y)
                    as.integer(x * y)))
    
    testInterface <-
      setJavaInterfaceImplementation(testInterfaceImplementation)
    
    ti <- testInterface$new('TestInterface',
                            testInterfaceImplementation)
    
    stopifnot(ti$mogrify('test') == ti$proxy$mogrify('test'))
    
  #+END_SRC  

  example of =RcreateObject= on =RInterfaceProxy=:

  #+BEGIN_SRC R
    new('jobjRef',
        jobj=.External('RcreateObject',
          'RInterfaceProxy',
          'TestInterface',
          to.hashmap(list(mogrify=function(string)
                          paste(string, 'mogrified', sep='-'),
                          tetradicSum=function(w, x, y, z)
                          sum(w, x, y, z),
                          multiplyInts=function(x, y)
                          as.integer(x * y)))),
        jclass='RInterfaceProxy')$newInstance()$tetradicSum(1, 2, 3, 4)
  #+END_SRC
* TODO implementations as reference classes instead of lists
  from [[http://stat.ethz.ch/R-manual/R-devel/library/methods/html/refClass.html][refClass]]:

  #+BEGIN_QUOTE
  Fields may be modified in a method by using the non-local assignment
  operator, =<<-=.

  The call to setRefClass defines the specified class and returns a
  “generator” object for that class.

  - =$new(...)= :: This method is equivalent to the function new with
                   the class name as an argument. The =...= arguments
                   are values for the named fields. If the class has a
                   method defined for =$initialize()=, this method
                   will be called once the reference object has been
                   created.
                   
                   The default method for =$initialize()= is
                   equivalent to invoking the method
                   =$initFields(...)= with named fields as its
                   arguments.
  #+END_QUOTE

  see [[http://dirk.eddelbuettel.com/blog/2010/10/15/][dirk's blog]]:

  #+BEGIN_QUOTE
  new =Rcpp::Reference= class, that allows internal manipulation of R
  2.12.0 reference classes. The class exposes a constructor that takes
  the name of the target reference class and a field(string) method
  that implements the proxy pattern to get/set reference fields using
  callbacks to the R operators =$= and =$<-= in order to preserve the
  R-level encapsulation.
  #+END_QUOTE
* TODO use proper namespacing
  =com/gene/rJavax=, etc.
* TODO switch to ant instead of Makefiles
  can even use [[http://cran.r-project.org/web/packages/ant/index.html][ant]] (but it's really just a wrapper around =system=).
* DONE package preamble for testing
  CLOSED: [2011-04-13 Wed 12:38]
  #+srcname: preamble
  #+BEGIN_SRC R
    library(rJava)
    source('R/interface.R')
    
    .jpackage('rJavax', morePaths='.')
    .jengine(TRUE)
    
  #+END_SRC
* DONE reference class inheriting from =jobjRef=
  CLOSED: [2011-04-13 Wed 12:38]
  #+BEGIN_SRC R :noweb yes :tangle test-inheritance.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    <<preamble>>
    
    ir <- setRefClass('jobjInterfaceRef', contains='jobjRef')
    
    ir$new(jobj=.External('RcreateObject', 'java/lang/Object', PACKAGE='rJava'),
           jclass='java/lang/Object')
    
  #+END_SRC
* DONE R package
  CLOSED: [2011-04-11 Mon 05:50]
  - CLOSING NOTE [2011-04-11 Mon 05:51] \\
    used =helloJavaWorld= as prototype; abusing the top-level =src=
    directory for Java: questionable? also, we're generating rJava.jar
    during installation, whereas =helloJavaWorld= and co. just check
    in the binary jars.
  this seems vaguely relevant, but i'm not sure how (from [[http.://cran.r-project.org/doc/manuals/R-exts.pdf][R-exts.pdf]]):

  #+BEGIN_QUOTE
  In some rare circumstances, the configuration and cleanup scripts
  need to know the location into which the package is being
  installed. An example of this is a package that uses C code and
  creates two shared object/DLLs. Usually, the object that is
  dynamically loaded by R is linked against the second, dependent,
  object. On some systems, we can add the location of this dependent
  object to the object that is dynamically loaded by R. This means
  that each user does not have to set the value of the
  =LD_LIBRARY_PATH= (or equivalent) environment variable, but that the
  secondary object is automatically resolved. Another example is when
  a package installs support files that are required at run time, and
  their location is substituted into an R data structure at
  installation time. (This happens with the Java Archive files in the
  SJava package.) The names of the top-level library directory (i.e.,
  specifiable via the =‘-l’= argument) and the directory of the
  package itself are made available to the installation scripts via
  the two shell/environment variables =R_LIBRARY_DIR= and
  =R_PACKAGE_DIR=. Additionally, the name of the package
  (e.g. =‘survival’= or =‘MASS’=) being installed is available from
  the environment variable =R_PACKAGE_NAME=. (Currently the value of
  =R_PACKAGE_DIR= is always =${R_LIBRARY_DIR}/${R_ PACKAGE_NAME}=, but
  this used not to be the case when versioned installs were
  allowed. Its main use is in =‘configure.win’= scripts for the
  installation path of external software’s DLLs.)
  #+END_QUOTE
 
  we're going to have to do a =configure.ac=, which does
  =AC_SUBST(...)= and =AC_CONFIG_FILES([...R])= to formalize
  =CLASSPATH=, =JAVA_LIBRARY_PATH=; as well as some kind of shell
  script to invoke =R= properly, which formalizes =LD_LIBRARY_PATH=.

  we're going to have to abuse =src= to build =RInterfaceProxy.jar=;
  let's do it over =Makefile=, possibly via =configure.ac= (and not,
  say, =ant=).

* DONE pass values to interface-methods
  CLOSED: [2011-04-04 Mon 03:30]
  - CLOSING NOTE [2011-04-04 Mon 03:30] \\
    works for some native types; not yet, however, for arbitrary classes.
  there are some mixups, somehow, while translating between Java and
  R.
* DONE return values from invocation-handler
  CLOSED: [2011-03-30 Wed 06:10]
  - CLOSING NOTE [2011-03-30 Wed 06:10] \\
    this doesn't work for the given example, of course, because the
    interface-method returns =void=!
* DONE register R-functions with a Java-proxy
  CLOSED: [2011-03-30 Wed 05:42]
  - CLOSING NOTE [2011-03-30 Wed 05:43] \\
    couple weirdnesses: can't preserve =REXPReferences= via =toJava= in
    named lists (though converting to vectors over =.jarray=); resorted,
    therefore, to a =HashMap=.
    
    also, can't return anything but =null= from the =InvocationHandler=.
  #+BEGIN_SRC R :tangle test-mogrifier.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit(classpath=Sys.getenv('CLASSPATH'),
           parameters=sprintf('-Djava.library.path=%s',
             Sys.getenv('JAVA_LIBRARY_PATH')))
    .jengine(TRUE)
    
    merge.lists <- function(...) {
      list = do.call(c, list(...))
      list[unique(names(do.call(c, list)))]
    }
    
    to.hashmap <- function(implementations) {
      hashmap <- new(J('java.util.HashMap'))
    
      ## Some things that Java expects of Objects.
      default.implementations <- list(toString=function()
                                      "RInterfaceProxy")
    
      implementations <-
        merge.lists(implementations,
                    default.implementations)
      
      ## Really need a Foreach here, since we're not using the return
      ## value.
      Map(function(name, implementation)
          hashmap$put(name, toJava(implementation)),
          names(implementations),
          implementations)
      hashmap
    }
    
    proxy <- new(J('RInterfaceProxy'),
      'Mogrifier',
      to.hashmap(list(mogrify=function(string)
                      paste(string, 'mogrified', sep='-'),
                      tetradicSum=function(w, x, y, z)
                      sum(w, x, y, z),
                      multiplyInts=function(x, y)
                      as.integer(x * y))))
    
    mogrifier <- proxy$newInstance()
    
    stopifnot(mogrifier$mogrify('totally') == 'totally-mogrified')
    
    stopifnot(mogrifier$tetradicSum(1, 2, 3, 4) == 10)
    
    stopifnot(mogrifier$multiplyInts(as.integer(2), as.integer(4)) == 8)
    
  #+END_SRC

  #+BEGIN_SRC java :tangle RInterfaceProxy.java
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Set;
    
    import org.rosuda.REngine.RList;
    import org.rosuda.REngine.REngine;
    import org.rosuda.REngine.REXP;
    import org.rosuda.REngine.REXPDouble;
    import org.rosuda.REngine.REXPInteger;
    import org.rosuda.REngine.REXPFactor;
    import org.rosuda.REngine.REXPLanguage;
    import org.rosuda.REngine.REXPList;
    import org.rosuda.REngine.REXPRaw;
    import org.rosuda.REngine.REXPReference;
    import org.rosuda.REngine.REXPString;
    import org.rosuda.REngine.REXPWrapper;
    import org.rosuda.REngine.JRI.JRIEngine;
    
    public class RInterfaceProxy {
        String interfaceName;
        HashMap<String, REXPReference> implementations;
        InvocationHandler handler;
        static HashMap<Class, Method> translations;
    
        public RInterfaceProxy(String interfaceName,
                               HashMap<String, REXPReference> implementations) {
            this.interfaceName = interfaceName;
            this.implementations = implementations;
            this.handler = makeInvocationHandler();
        }
    
        static {
            try {
                translations =
                    new HashMap<Class, Method>() {
                    {
                        put(REXPString.class,
                            REXPString.class.getMethod("asString"));
                        put(REXPRaw.class,
                            REXPRaw.class.getMethod("asBytes"));
                        put(REXPDouble.class,
                            REXPDouble.class.getMethod("asDouble"));
                        put(REXPFactor.class,
                            REXPFactor.class.getMethod("asFactor"));
                        put(REXPInteger.class,
                            REXPInteger.class.getMethod("asInteger"));
                        put(REXPList.class,
                            REXPList.class.getMethod("asList"));                    
                    }
                };
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
    
        public InvocationHandler makeInvocationHandler() {
            return new InvocationHandler() {
                public Object invoke(Object proxy,
                                     Method method,
                                     final Object[] args) {
                    try {
                        final REXPReference implementation =
                            RInterfaceProxy.this.implementations
                            .get(method.getName());
                        ArrayList<REXP> call = new ArrayList<REXP>() {
                            {
                                add(implementation);
                                for (Object arg: args) {
                                    add(REXPWrapper.wrap(arg));
                                }
                            }
                        };
                        REXP value = implementation.getEngine()
                            .eval(new REXPLanguage
                                  (new RList (call.toArray(new REXP[0]))),
                                null,
                                true);
                        // NB: need to handle the case where get returns
                        // null.
                        return RInterfaceProxy.translations
                            .get(value.getClass()).invoke(value);
                    } catch (Throwable e) {
                        e.printStackTrace();
                    }
                    return null;
                }
            };
        }
    
        public Object newInstance() {
            try {
                Class interfaceClass = Class.forName(interfaceName);
                return Proxy.newProxyInstance(interfaceClass.getClassLoader(),
                                              new Class[] { interfaceClass },
                                              handler);
            } catch (Throwable e) {
                e.printStackTrace();
            }
    
            return null;
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC java :tangle Mogrifier.java
    import org.rosuda.REngine.REXP;
    
    public interface Mogrifier {
        public String mogrify(String string);
        public double tetradicSum(double w, double x, double y, double z);
        public int multiplyInts(int x, int y);
    }
    
  #+END_SRC
* DONE calling a java function (given a class) from within rJava
  CLOSED: [2011-03-30 Wed 02:32]
  - CLOSING NOTE [2011-03-30 Wed 02:33] \\
    requires, however, a non-trivial environment (see [[./Makefile][Makefile]]).
  #+BEGIN_SRC java :tangle TrivialFunction.java
    public class TrivialFunction {
        public void trivialFunction() {
            System.out.println("hello, pseudo-trivial world!");
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC R :tangle test-java-function.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit(classpath=Sys.getenv('CLASSPATH'),
           parameters=sprintf('-Djava.library.path=%s',
             Sys.getenv('JAVA_LIBRARY_PATH')))
    tf = .jnew('TrivialFunction')
    .jcall(tf, 'V', 'trivialFunction')
    
  #+END_SRC
* DONE dispatch on proxy-method (Java) -> implementation-method (R) dictionary
  CLOSED: [2011-03-30 Wed 05:43]
  this will require a call from R to Java to the effect of: this named
  list of procedures implements that interface.

  see [[notes-2011-03-28][notes]].
* DONE example of a proxy
  CLOSED: [2011-03-28 Mon 09:40]
  #+BEGIN_SRC java :tangle TestInterfaceProxy.java
    import java.lang.StringBuilder;
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.util.Formatter;
    
    import org.rosuda.REngine.JRI.JRIEngine;
    import org.rosuda.REngine.REngine;
    import org.rosuda.REngine.REngineStdOutput;
    
    import org.apache.commons.lang3.RandomStringUtils;
    
    interface A {
        String b(String c, String d);
    }
    
    class TestInterfaceProxy {
        static REngine re;
    
        public static void main(String[] argv) throws Throwable {
            InvocationHandler handler = new InvocationHandler() {
                    public Object invoke(Object proxy,
                                         Method method,
                                         Object[] args) {
                        try {
                            StringBuilder evalArgs = new StringBuilder();
                            for (Object arg: args) {
                                // http://stackoverflow.com/questions/41107/how-to-generate-a-random-alpha-numeric-string-in-java
                                String identifier = RandomStringUtils.randomAlphabetic(32);
                                // http://tolstoy.newcastle.edu.au/R/help/04/04/0847.html
                                re.assign(identifier, (String) arg);
                                evalArgs.append(identifier);
                                evalArgs.append(",");
                            };
                            if (evalArgs.length() > 0)
                                evalArgs.deleteCharAt(evalArgs.length() - 1);
                            return re.parseAndEval(String.format("%s(%s)",
                                                                 method.getName(),
                                                                 evalArgs)).asString();
                        } catch (Throwable e) {
                            e.printStackTrace();
                            // re.end();
                        }
                        System.out.println(method);
                        return new Object();
                    };
                };
            A a = (A) Proxy.newProxyInstance(A.class.getClassLoader(),
                                             new Class[] { A.class },
                                             handler);
            
            re = JRIEngine.createEngine(new String[] { "--vanilla", "--slave" },
                                        new REngineStdOutput(),
                                        false);
    
            re.parseAndEval("b <- function(c, d) paste(c, d)");
     
            assert a.b("hello", "world").equals("hello world");
     
            re.close();
        }
    }
  #+END_SRC
* Notes
** Mon Mar 28 10:50:13 PDT 2011
# <<notes-2011-03-28>>
   we'll have the REXPs corresponding to closures; look at
   =Rengine.Rengine= not =JRI.Rengine=; we'll have a list of REXPs.

   register list of functions, state saved in InvocationHandler; give
   as a return value IH; return an IH whose constructor takes the
   dictionary; custom java code implementing IH; class generator in
   reference class, wrapper around invocation handler.

   implementInterface, pass dictionary: get constructor or
   implementation handler; return the closure, if they call the
   closure, they get an object; think about state at some point.

   list of methods declared in the interface.
** Mon Apr  4 10:22:25 PDT 2011
   build our own JRI class with appropriate slots; create S4 objects:
   special call in C.

   wrap it in R package; test suite; reference class; nice interface.

   generator object: setRefClass; initialize method on class; every
   reference object reference to java object that underlies it;
   initialize method: sets up reference; wrapper methods for each
   method in interface; send to setRefClass; fields: active bindings;
   setRefClass gives back class generator; use normal reference class
   api to construct objects.

   setRefClass for any interface, class; given a reference to a java
   object; instantiate reference class, have underlying java
   object. more general than implementing of interfaces; any interface
   has an equivalent refClass.

   don't have a named class yet; define a new interface: gives them
   back a reference; interface has been pre-defined by java; maintain:
   class-name map; interface implementation, gives them back reference
   generator object; wrappers could be shared across class, interface;
   difference is in initialize method;

   related but orthogonal: wrapJavaClass, proxyJavaClass; for any
   named class: can get a generator; call directly from R, not Java.

   initialize function: does what that closure what do: calls the
   proxy method; generalize it, though, so that we can proxy any java
   class; .jnew on the named class; allowing it to take a function in
   the constructor; what does the constructor do? sort of like the
   initialize method: instance exists, initializes instance.

   get a java object from initialize: pass to constructor/initializer;
   override initialization: can take arguments, fields.

   fancy: custom initializers.
** Mon Apr 11 10:13:54 PDT 2011
   implement not only interfaces but classes; worry about fields
   later; methods wrappers for .jcall, etc.; initialize()
   constructor. methods on the reference class just R functions
   themselves?

   right now: list, expect them to be called from java; instead of
   calling java to call R; instead: use functions directly as methods;
   for calling things from R, short circuit it by calling the
   implementation methods directly; pass it directly to the
   =setRefClass= call (=methods=); once it's =setRefClass=, semantics
   are somewhat different (not necessarily drop-in); if implementing
   java interface, want to use those features anyway; if something is
   called from java, will it work if it uses these reference class
   features; right enclosure; they parse methods with codetools; need
   to make sure: same function; enclosing environment hasn't
   changed. need to make sure that the function called from java is
   the same function as called directly; people want the ability to be
   able to say, this, self, and have things work correctly; if were
   not doing this, self; pass methods into setRefClass and get
   something corresponding to that function back out; own version of
   the method enclosed in that instance environment;

   when i implement this: closures? need some kind of mutable
   state. how would that work with a single closure per class; static
   state vs. class-level state; support instance-level state;

   setRefClass: implement function? proxy refClass for classes *or*
   interfaces; reference classes for extensions of java; c++:
   extensions of c++ classes in R, c++ cannot see the R
   implementations; what we'd like to do: at least at the interface
   level, have java see the R implementation;

   should they be writing code in the reference class style? (pretty
   compatible with java, etc.)

   discrete steps: 1. setRefClass, 2. implements interface; needs to
   be able to get the methods enclosed in the instance; different set
   of functions for every instance; create a new invocation handler
   instance in initialize(); setJavaReferenceClass? given a java
   class, create corresponding reference class; rcpp: allows them to
   add on new methods; setRefClass call; that's where the
   introspection comes in in initialization(); interfaces only
   supported through java Proxy; currently only interfaces; later
   class; give setJavaReferenceClass a list of character vectors
   naming all the interfaces you want to implement; for now, single
   interface; in the multiple interface case: methods() would be a
   list of lists; conflicting method names in multiple interface
   implementation; setJavaReferenceClass is a wrapper around
   setRefClass: given name of java class or opaque class object,
   introspect it, come up with a bunch of stubs that delegate up
   through the rjava interface; setJavaImplementation; if the class
   doesn't exist yet; if we want it to mimic java, how far do you go?;
   at least need to represent all the parent classes of a given
   object; represent e.g. java.lang.Object as reference class when
   reference-classing java.lang.reflect.Proxy;

   just make it work with the interfaces we've implemented? rJava
   already similar to reference classes ($, etc.): what is the
   advantages to these proxies? rcpp, same playing field, etc.;
   correct about it: lot of overhead; trying to mimic rcpp, write cpp
   in package, want to be able to call them from R via reference
   classes; qt cpp stuff released in about a month through
   bioconductor; not much point to a reference class if not
   bidirectional; decide to what extent we're going to do the mapping;
   introspecting entire class hierarchy not practical;

   reference class stuff for this interface stuff;
   setJavaInterfaceImplementation: name of interface, list of methods
   (weren't going to do short-circuiting);

   setJavaInterfaceImplementation: name, list of methods; from name,
   look up ref class; inherit from that class; for implementations:
   pass to java, inherited proxy methods, into location handler; other
   way: short circuit; override methods with our implementations; call
   these things directly from within R; during initialize methods, go
   in get methods out, pass them on to invocation handler; setJII:
   calls setRefClass, initialize(): get the methods out of the
   instance, take them and pass them to the constructor of the proxy;
   make it so that we can get from reference class object the
   corresponding java object (jObjRef); every one of these guys should
   inherit from some base references class that has a method to access
   the jObjRef; somehow access generator object; test: short-circuited
   call from within R, long route through java; translate between two
   representations; 

   all of our reference classes inherit from jObjRef; has the
   necessary slots; pass that as any java interface transparently;
   reference class inherit from S4; 
** Wed Apr 13 14:09:14 PDT 2011
   =initialize()= calls constructor on java object; just copy the
   =jobj= and the =jclass= slots.

   =com.gene.bioinfo.R=

   mimic what john did with Rcpp; 
** Mon Apr 18 10:10:59 PDT 2011
   every java interface or class: has a reference class version of it;
   signify instance, every java superclass; stub java implementations
   that merely call the java methods, except where overridden;
   contains: names of classes; all the parent-implementing R classes
   as a flat list in the ;

   contains: all the interfaces that it implements and its parent
   implementations; trace the interfaces up to parentlessness;

   fields support active bindings; construct an active binding;
   substitute on the body; jobjRef, subinterface, multiple interface.

   substitute outside the function definition.
