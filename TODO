# -*- org -*-
* TODO pass values to interface-methods
  there are some mixups, somehow, while translating between Java and
  R.
* DONE return values from invocation-handler
  CLOSED: [2011-03-30 Wed 06:10]
  - CLOSING NOTE [2011-03-30 Wed 06:10] \\
    this doesn't work for the given example, of course, because the
    interface-method returns =void=!
* DONE register R-functions with a Java-proxy
  CLOSED: [2011-03-30 Wed 05:42]
  - CLOSING NOTE [2011-03-30 Wed 05:43] \\
    couple weirdnesses: can't preserve =REXPReferences= via =toJava= in
    named lists (though converting to vectors over =.jarray=); resorted,
    therefore, to a =HashMap=.
    
    also, can't return anything but =null= from the =InvocationHandler=.
  #+BEGIN_SRC R :tangle test-mogrifier.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit(classpath=Sys.getenv('CLASSPATH'),
           parameters=sprintf('-Djava.library.path=%s',
             Sys.getenv('JAVA_LIBRARY_PATH')))
    .jengine(TRUE)
    
    merge.lists <- function(...) {
      list = do.call(c, list(...))
      list[unique(names(do.call(c, list)))]
    }
    
    to.hashmap <- function(implementations) {
      hashmap <- new(J('java.util.HashMap'))
    
      ## Some things that Java expects of Objects.
      default.implementations <- list(toString=function()
                                      "RInterfaceProxy")
    
    
      implementations <-
        merge.lists(implementations,
                    default.implementations)
      
      ## Really need a Foreach here, since we're not using the return
      ## value.
      Map(function(name, implementation)
          hashmap$put(name, toJava(implementation)),
          names(implementations),
          implementations)
      hashmap
    }
    
    proxy <- new(J('RInterfaceProxy'),
      'Mogrifier',
      to.hashmap(list(mogrify=function(string)
                      paste(string, 'mogrified', sep='-'))))
    
    stopifnot(proxy$newInstance()$mogrify('totally') == 'totally-mogrified')
    
  #+END_SRC

  #+BEGIN_SRC java :tangle RInterfaceProxy.java
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Set;
    
    import org.rosuda.REngine.RList;
    import org.rosuda.REngine.REngine;
    import org.rosuda.REngine.REXP;
    import org.rosuda.REngine.REXPReference;
    import org.rosuda.REngine.REXPLanguage;
    import org.rosuda.REngine.REXPWrapper;
    import org.rosuda.REngine.JRI.JRIEngine;
    
    public class RInterfaceProxy {
        public String interfaceName;
        public HashMap<String, REXPReference> implementations;
        public InvocationHandler handler;
    
        public RInterfaceProxy(String interfaceName,
                               HashMap<String, REXPReference> implementations) {
            this.interfaceName = interfaceName;
            this.implementations = implementations;
            this.handler = makeInvocationHandler();
        }
    
        public InvocationHandler makeInvocationHandler() {
            return new InvocationHandler() {
                public Object invoke(Object proxy,
                                     Method method,
                                     final Object[] args) {
                    try {
                        final REXPReference implementation =
                            RInterfaceProxy.this.implementations
                            .get(method.getName());
                        ArrayList<REXP> call = new ArrayList<REXP>() {
                            {
                                add(implementation);
                                for (Object arg: args) {
                                    add(REXPWrapper.wrap(arg));
                                }
                            }
                        };
                        REXP value = implementation.getEngine()
                            .eval(new REXPLanguage(new RList(call.toArray(new REXP[0]))),
                                null,
                                false);
                        return value.asString();
                    } catch (Throwable e) {
                        e.printStackTrace();
                    }
                    return null;
                }
            };
        }
    
        public Object newInstance() {
            try {
                Class interfaceClass = Class.forName(interfaceName);
                return Proxy.newProxyInstance(interfaceClass.getClassLoader(),
                                              new Class[] { interfaceClass },
                                              handler);
            } catch (Throwable e) {
                e.printStackTrace();
            }
    
            return null;
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC java :tangle Mogrifier.java
    import org.rosuda.REngine.REXP;
    
    public interface Mogrifier {
        public String mogrify(String string);
    }
    
  #+END_SRC
* DONE calling a java function (given a class) from within rJava
  CLOSED: [2011-03-30 Wed 02:32]
  - CLOSING NOTE [2011-03-30 Wed 02:33] \\
    requires, however, a non-trivial environment (see [[./Makefile][Makefile]]).
  #+BEGIN_SRC java :tangle TrivialFunction.java
    public class TrivialFunction {
        public void trivialFunction() {
            System.out.println("hello, pseudo-trivial world!");
        }
    }
    
  #+END_SRC

  #+BEGIN_SRC R :tangle test-java-function.R :shebang #!/usr/local/bin/R --vanilla --slave -f
    library(rJava)
    .jinit(classpath=Sys.getenv('CLASSPATH'),
           parameters=sprintf('-Djava.library.path=%s',
             Sys.getenv('JAVA_LIBRARY_PATH')))
    tf = .jnew('TrivialFunction')
    .jcall(tf, 'V', 'trivialFunction')
    
  #+END_SRC
* DONE dispatch on proxy-method (Java) -> implementation-method (R) dictionary
  CLOSED: [2011-03-30 Wed 05:43]
  this will require a call from R to Java to the effect of: this named
  list of procedures implements that interface.

  see [[notes-2011-03-28][notes]].
* DONE example of a proxy
  CLOSED: [2011-03-28 Mon 09:40]
  #+BEGIN_SRC java :tangle TestInterfaceProxy.java
    import java.lang.StringBuilder;
    import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;
    import java.util.Formatter;
    
    import org.rosuda.REngine.JRI.JRIEngine;
    import org.rosuda.REngine.REngine;
    import org.rosuda.REngine.REngineStdOutput;
    
    import org.apache.commons.lang3.RandomStringUtils;
    
    interface A {
        String b(String c, String d);
    }
    
    class TestInterfaceProxy {
        static REngine re;
    
        public static void main(String[] argv) throws Throwable {
            InvocationHandler handler = new InvocationHandler() {
                    public Object invoke(Object proxy,
                                         Method method,
                                         Object[] args) {
                        try {
                            StringBuilder evalArgs = new StringBuilder();
                            for (Object arg: args) {
                                // http://stackoverflow.com/questions/41107/how-to-generate-a-random-alpha-numeric-string-in-java
                                String identifier = RandomStringUtils.randomAlphabetic(32);
                                // http://tolstoy.newcastle.edu.au/R/help/04/04/0847.html
                                re.assign(identifier, (String) arg);
                                evalArgs.append(identifier);
                                evalArgs.append(",");
                            };
                            if (evalArgs.length() > 0)
                                evalArgs.deleteCharAt(evalArgs.length() - 1);
                            return re.parseAndEval(String.format("%s(%s)",
                                                                 method.getName(),
                                                                 evalArgs)).asString();
                        } catch (Throwable e) {
                            e.printStackTrace();
                            // re.end();
                        }
                        System.out.println(method);
                        return new Object();
                    };
                };
            A a = (A) Proxy.newProxyInstance(A.class.getClassLoader(),
                                             new Class[] { A.class },
                                             handler);
            
            re = JRIEngine.createEngine(new String[] { "--vanilla", "--slave" },
                                        new REngineStdOutput(),
                                        false);
    
            re.parseAndEval("b <- function(c, d) paste(c, d)");
     
            assert a.b("hello", "world").equals("hello world");
     
            re.close();
        }
    }
  #+END_SRC
* Notes
** Mon Mar 28 10:50:13 PDT 2011
# <<notes-2011-03-28>>
   we'll have the REXPs corresponding to closures; look at
   =Rengine.Rengine= not =JRI.Rengine=; we'll have a list of REXPs.

   register list of functions, state saved in InvocationHandler; give
   as a return value IH; return an IH whose constructor takes the
   dictionary; custom java code implementing IH; class generator in
   reference class, wrapper around invocation handler.

   implementInterface, pass dictionary: get constructor or
   implementation handler; return the closure, if they call the
   closure, they get an object; think about state at some point.

   list of methods declared in the interface.
